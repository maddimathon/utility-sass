/**
 * @since 0.1.0-alpha.draft
 *
 * @packageDocumentation
 */
/*!
 * @maddimathon/utility-sass@0.1.0-alpha.draft
 * @license MIT
 */
// import { node } from '@maddimathon/utility-typescript/classes';
import { DesignTokens } from './DesignTokens.js';
/**
 * This class runs the CLI.
 *
 * @since 0.1.0-alpha.draft
 */
export class CLI {
    params;
    // protected readonly fs: node.NodeFiles;
    // protected readonly nc: node.NodeConsole;
    constructor(params) {
        this.params = params;
        // this.nc = new node.NodeConsole( {} );
        // this.fs = new node.NodeFiles( {}, { nc: this.nc } );
    }
    /**
     * Runs the command according to the passed params.
     */
    go() {
        const scriptName = (this.params._?.[0]);
        switch (scriptName) {
            case 'compile-tokens':
                return this.compileTokens();
            case 'debug':
                this.params.debug = true;
                return this.help();
            case 'help':
                return this.help();
            default:
                return this.unknownCommand();
        }
    }
    async compileTokens() {
        // this.nc.varDump( { params: this.params } );
        // returns
        if (!this.params.out) {
            // this.nc.log( 'An --out parameter is required to write tokens.' );
            return;
        }
        // returns
        if (typeof this.params.out !== 'string') {
            // this.nc.log( 'The --out parameter must be a string.' );
            return;
        }
        let input = undefined;
        // if ( this.params.in && typeof this.params.in === 'string' ) {
        //     if ( !this.fs.exists( this.params.in ) ) {
        //         this.nc.log( `The --in parameter path (${ this.params.in }) doesn't exist.` );
        //     } else {
        //         const _obj = ( await import( this.params.in ) ).default;
        //         if ( typeof _obj !== 'object' ) {
        //             this.nc.log( `The --in parameter path (${ this.params.in }) should default-export an object.` );
        //         } else {
        //             input = _obj;
        //         }
        //     }
        // }
        const tokens = new DesignTokens(input ?? DesignTokens.DEFAULT);
        const tokensExport = tokens.toSCSS();
        const scss = [
            '// this file is auto-generated by the utility-sass CLI',
        ];
        const defaultString = this.params.tokensAsDefault ? ' !default' : '';
        for (const t_key in tokensExport) {
            const _key = t_key;
            scss.push(`$${_key}: ${tokensExport[_key]}${defaultString};`);
        }
        // this.fs.write(
        //     this.params.out,
        //     scss.join( '\n\n' ),
        //     { force: true, rename: false }
        // );
    }
    help() { }
    unknownCommand() { }
}
/**
 * Utilities for the {@link CLI} class.
 *
 * @since 0.1.0-alpha.draft
 */
(function (CLI) {
    /**
     * Variations of the input params depending on command.
     *
     * @since 0.1.0-alpha.draft
     */
    let Params;
    (function (Params) {
        ;
    })(Params = CLI.Params || (CLI.Params = {}));
    ;
})(CLI || (CLI = {}));
//# sourceMappingURL=CLI.js.map